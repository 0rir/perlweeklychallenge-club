(module
  (memory (export "factorial_table") 1)

  ;; Generated by: raku -e 'sub HexStr ($_) { <"> ~ .polymod(256 xx 3).fmt(<\\%02X>, Q<>) ~ <">} ;say "(data (i32.const 0x{(.key * 4).fmt: <%02X>}) { HexStr(.value) })  ;; {.key}! == {.value.fmt: <%6d>}" for (1, |[\*] 1..9).flat.pairs;' | m
  (data (i32.const 0x00) "\01\00\00\00")  ;; 0! ==      1
  (data (i32.const 0x04) "\01\00\00\00")  ;; 1! ==      1
  (data (i32.const 0x08) "\02\00\00\00")  ;; 2! ==      2
  (data (i32.const 0x0C) "\06\00\00\00")  ;; 3! ==      6
  (data (i32.const 0x10) "\18\00\00\00")  ;; 4! ==     24
  (data (i32.const 0x14) "\78\00\00\00")  ;; 5! ==    120
  (data (i32.const 0x18) "\D0\02\00\00")  ;; 6! ==    720
  (data (i32.const 0x1C) "\B0\13\00\00")  ;; 7! ==   5040
  (data (i32.const 0x20) "\80\9D\00\00")  ;; 8! ==  40320
  (data (i32.const 0x24) "\80\89\05\00")  ;; 9! == 362880

  (func $is_factorion (export "is_factorion") (param $n i32) (result i32)
    (local $digit   i32)  ;; Right-most digit of (the bleeding copy of) $n
    (local $bleeder i32)  ;; Copy of $n that is "bled" of its right-most digit
    (local $offset  i32)  ;; Offset into the factorial_table
    (local $fact    i32)  ;; Factorial of the digit, pulled from the table
    (local $acc     i32)  ;; Accumulator

    (set_local $bleeder (get_local $n))   ;; $bleeder = $n

    (loop $accumulate
      (set_local $digit   (i32.rem_u (get_local $bleeder) (i32.const 10    ) ))  ;; $digit     = $bleeder % 10;
      (set_local $bleeder (i32.sub   (get_local $bleeder) (get_local $digit) ))  ;; $bleeder  -= $digit;
      (set_local $bleeder (i32.div_u (get_local $bleeder) (i32.const 10    ) ))  ;; $bleeder  /= 10;
      (set_local $offset  (i32.mul   (get_local $digit  ) (i32.const  4    ) ))  ;; $offset    = $digit * 4
      (set_local $fact    (i32.load  (get_local $offset )                    ))  ;; $factorial = @memory[$offset]
      (set_local $acc     (i32.add   (get_local $acc    ) (get_local $fact ) ))  ;; $acc      += $factorial

      (br_if $accumulate (get_local $bleeder))  ;; while $bleeder != 0
    )

    (i32.eq (get_local $n) (get_local $acc))    ;; return $n == $acc
  )
)
;; To test, go to https://webassembly.github.io/wabt/demo/wat2wasm/ ,
;; copy the code above to the WAT window (top-left),
;; and  the code below to the JS  window (bottom-left).
;; Output will be in the JS LOG   window (bottom-right).
const wasmInstance = new WebAssembly.Instance(wasmModule, {});
const { is_factorion } = wasmInstance.exports;
console.log(                    [145,123].map(is_factorion).join(', '));
console.log([...Array(2000000).keys()].filter(is_factorion).join(', '));
// Output is:
//    1, 0
//    1, 2, 145, 40585
